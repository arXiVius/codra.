<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Codra CLI</title>
    <!-- React and ReactDOM from CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel for JSX transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Tailwind CSS for a clean, modern look -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- JS-YAML for YAML <-> JSON conversion -->
    <script src="https://unpkg.com/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
    <!-- QR Code Library for generating QR codes -->
    <script src="https://unpkg.com/qrcode-svg@1.1.0/lib/qrcode.min.js"></script>
    <!-- jsQR for decoding QR codes from images -->
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.0.0/dist/jsQR.min.js"></script>
    <!-- Day.js for date and time formatting -->
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.10/dayjs.min.js"></script>

    <style>
        /* Import Google Fonts for a clean look */
        @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
        }

        .terminal-font {
            font-family: 'IBM Plex Mono', monospace;
        }

        /* Hide scrollbar for a cleaner look */
        .scrollbar-hide {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        .scrollbar-hide::-webkit-scrollbar {
            display: none;
        }

        /* Consistent form styling for the GUI, now matching the CLI theme */
        .gui-input, .gui-select-button {
            @apply w-full p-3 rounded-lg border border-gray-700 bg-black bg-opacity-80 text-green-400 focus:outline-none focus:ring-2 focus:ring-green-500;
        }
    </style>
</head>
<body class="bg-gray-900 text-green-400">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Language data for internationalization (now English only)
        const strings = {
            welcome: 'Welcome to Codra., your comprehensive dev/sec toolkit.',
            help: 'Type `help` to see a list of available commands.',
            gui: 'Type `gui` to switch to a graphical interface.',
            cli: 'Switched to Terminal mode.',
            exit: 'Cannot exit terminal. To close, simply close this tab.',
            guiTitle: 'Codra GUI',
            selectTool: 'Select a Tool:',
            run: 'Run',
            output: 'Output:',
            returnToCli: 'Return to CLI',
            toolNames: {
                'password-gen': 'Password Generator',
                'password-check': 'Password Checker',
                'url-encode': 'URL Encoder',
                'url-decode': 'URL Decoder',
                'base64-encode': 'Base64 Encoder',
                'base64-decode': 'Base64 Decoder',
                'myip': 'My Public IP',
                'qr-gen': 'QR Code Generator',
                'qr-decode': 'QR Code Decoder',
                'unit-converter': 'Unit Converter',
                'rev-dns': 'Reverse DNS',
                'image-to-grayscale': 'Image to Grayscale',
                'base64-to-image': 'Base64 to Image',
                'url-shorten': 'URL Shortener',
                'ip-to-binary': 'IP to Binary',
                'markdown-to-json': 'Markdown to JSON',
                'hex-to-rgb': 'Hex to RGB',
                'rgb-to-hex': 'RGB to Hex',
                'validate-email': 'Validate Email',
                'validate-credit-card': 'Validate CC',
                'user-agent': 'User Agent'
            },
            inputPlaceholder: 'Enter text or URL here...',
            commandsTitle: 'Available Commands:',
            commands: [
                '• clear                  - Clears the terminal screen for a fresh start.',
                '• clear-history          - Permanently clears all saved terminal history.',
                '• help                   - Displays this help message.',
                '• gui                    - Toggles to a simple graphical interface.',
                '',
                'Programming & Data Tools:',
                '• hash <text>            - Generates a SHA-256 hash for text.',
                '• base64 <action> <text> - Encodes or decodes Base64 text. Actions: encode, decode',
                '• url-encode <text>      - URL-encodes a string.',
                '• url-decode <text>      - URL-decodes a string.',
                '• json-format <json>     - Formats a JSON string with indentation.',
                '• string-reverse <text>  - Reverses a given string.',
                '• string-count <text>    - Counts characters, words, and lines.',
                '• case-convert <case> <text> - Converts text case. Cases: upper, lower, title, camel, snake, kebab',
                '• rot13 <text>           - Encodes text using the ROT13 cipher.',
                '• epoch                  - Gets the current Unix timestamp and date.',
                '• timestamp-to-date <ts> - Converts a Unix timestamp to a human date.',
                '• markdown-to-html <md>  - Converts basic Markdown to HTML.',
                '• json-to-yaml <json>    - Converts JSON to YAML.',
                '• yaml-to-json <yaml>    - Converts YAML to JSON.',
                '• convert <value> <from> to <to> - Converts units (e.g., `1024 B to KB`).',
                '• qrcode-gen <text>      - Generates a QR code as a data URI for text.',
                '• qrcode-decode <url>    - Decodes a QR code from an image URL or data URI.',
                '',
                'Image & Graphics Tools:',
                '• image-to-grayscale <url> - Converts an image at the given URL to grayscale.',
                '• base64-to-image <b64>    - Decodes a Base64 string into an image.',
                '',
                'Network & Security Tools:',
                '• ip <address>           - Finds geolocation data for an IP address.',
                '• myip                   - Finds your public IP address.',
                '• dns-lookup <domain>    - Performs a DNS lookup for a domain.',
                '• rev-dns <ip>           - Performs a reverse DNS lookup for an IP.',
                '• url-shorten <url>      - Shortens a URL using a public API.',
                '• ip-to-binary <ip>      - Converts an IPv4 address to binary.',
                '• password-check <pass>  - Checks the strength of a password.',
                '• password-gen           - Generates a strong random password.',
                '• validate-email <email> - Validates an email address format.',
                '• validate-credit-card <num> - Validates a credit card number.',
                '',
                'System & Environment Tools:',
                '• user-agent             - Displays your browser\'s User-Agent string.'
            ],
            error: 'Error: Command not found:',
            missingArg: 'Error: Missing arguments.',
            myIpError: 'Error: Could not retrieve public IP.',
            apiError: 'Error: Could not connect to API.',
            invalidJson: 'Error: Invalid JSON string.',
            invalidUrl: 'Error: Invalid URL.',
            invalidBase64: 'Error: Invalid Base64 string or decoding failed.',
            invalidUnit: 'Error: Invalid unit or format. Use `convert <value> <from> to <to>`.',
            invalidQr: 'Error: Failed to decode QR code. Ensure the URL is valid and the image contains a readable QR code.',
            invalidImage: 'Error: Failed to load image. Ensure the URL is valid and accessible.',
            invalidHex: 'Error: Invalid hexadecimal color code.',
            invalidRgb: 'Error: Invalid RGB color format. Use "r,g,b" or "r g b".',
            invalidEmail: 'Error: Invalid email format.',
            invalidCreditCard: 'Error: Invalid credit card number.',
            luhnCheckFailed: 'Error: Luhn algorithm check failed.',
            urlShortenError: 'Error: Failed to shorten URL.'
        };

        // Custom Tool Dropdown Data
        const toolOptions = {
            'Programming & Data': [
                { id: 'password-gen', name: strings.toolNames['password-gen'] },
                { id: 'password-check', name: strings.toolNames['password-check'] },
                { id: 'url-encode', name: strings.toolNames['url-encode'] },
                { id: 'url-decode', name: strings.toolNames['url-decode'] },
                { id: 'base64-encode', name: strings.toolNames['base64-encode'] },
                { id: 'base64-decode', name: strings.toolNames['base64-decode'] },
                { id: 'unit-converter', name: strings.toolNames['unit-converter'] },
                { id: 'markdown-to-json', name: strings.toolNames['markdown-to-json'] },
                { id: 'hex-to-rgb', name: strings.toolNames['hex-to-rgb'] },
                { id: 'rgb-to-hex', name: strings.toolNames['rgb-to-hex'] },
            ],
            'Network & Security': [
                { id: 'myip', name: strings.toolNames['myip'] },
                { id: 'rev-dns', name: strings.toolNames['rev-dns'] },
                { id: 'url-shorten', name: strings.toolNames['url-shorten'] },
                { id: 'ip-to-binary', name: strings.toolNames['ip-to-binary'] },
                { id: 'validate-email', name: strings.toolNames['validate-email'] },
                { id: 'validate-credit-card', name: strings.toolNames['validate-credit-card'] },
            ],
            'Image & Graphics': [
                { id: 'qr-gen', name: strings.toolNames['qr-gen'] },
                { id: 'qr-decode', name: strings.toolNames['qr-decode'] },
                { id: 'image-to-grayscale', name: strings.toolNames['image-to-grayscale'] },
                { id: 'base64-to-image', name: strings.toolNames['base64-to-image'] },
            ],
            'System & Environment': [
                { id: 'user-agent', name: strings.toolNames['user-agent'] },
            ]
        };

        // --- Core Utility Functions ---

        // A simple check for password strength
        const handlePasswordCheck = (password) => {
            let score = 0;
            let output = [];
            if (password.length >= 8) score++;
            if (/[a-z]/.test(password)) score++;
            if (/[A-Z]/.test(password)) score++;
            if (/[0-9]/.test(password)) score++;
            if (/[!@#$%^&*()_+\-=[\]{};':"\\|,.<>/?]/.test(password)) score++;
            let strength;
            if (score <= 2) strength = 'Weak';
            else if (score <= 4) strength = 'Medium';
            else strength = 'Strong';
            output.push(`Password Strength: ${strength} (${score}/5)`);
            return output;
        };

        // Generates a random, strong password
        const handlePasswordGen = () => {
            const length = 16;
            const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+~`|}{[]:;?><,./-=";
            let password = "";
            for (let i = 0, n = charset.length; i < length; ++i) {
                password += charset.charAt(Math.floor(Math.random() * n));
            }
            return [`Generated Password: ${password}`];
        };

        // Handles URL encoding and decoding
        const handleUrlEncodeDecode = (action, text) => {
            try {
                if (action.toLowerCase() === 'url-encode') {
                    return [`Encoded: ${encodeURIComponent(text)}`];
                } else if (action.toLowerCase() === 'url-decode') {
                    return [`Decoded: ${decodeURIComponent(text)}`];
                }
            } catch (e) {
                return [`Error: Processing failed.`];
            }
        };

        // Handles Base64 encoding and decoding
        const handleBase64 = (action, text) => {
            try {
                if (action.toLowerCase() === 'encode') {
                    const encoded = btoa(text);
                    return [`Encoded: ${encoded}`];
                } else if (action.toLowerCase() === 'decode') {
                    const decoded = atob(text);
                    return [`Decoded: ${decoded}`];
                } else {
                    return ['Error: Invalid action. Use `encode` or `decode`.'];
                }
            } catch (e) {
                return [strings.invalidBase64];
            }
        };

        // Hashes text using SHA-256
        const handleTextHash = async (text) => {
            try {
                const encoder = new TextEncoder();
                const data = encoder.encode(text);
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                return [`SHA-256: ${hashHex}`];
            } catch (e) {
                return [`Error: Hashing failed.`];
            }
        };

        // Handles JSON formatting
        const handleJsonFormat = (jsonString) => {
            try {
                const obj = JSON.parse(jsonString);
                return [`Formatted JSON:\n${JSON.stringify(obj, null, 2)}`];
            } catch (e) {
                return [strings.invalidJson];
            }
        };

        // Handles string reversal
        const handleStringReverse = (text) => {
            return [`Reversed string: ${text.split('').reverse().join('')}`];
        };

        // Counts characters, words, and lines
        const handleStringCount = (text) => {
            const charCount = text.length;
            const wordCount = text.split(/\s+/).filter(word => word.length > 0).length;
            const lineCount = text.split('\n').length;
            return [
                `Character Count: ${charCount}`,
                `Word Count: ${wordCount}`,
                `Line Count: ${lineCount}`
            ];
        };

        // Converts text case
        const handleCaseConvert = (caseType, text) => {
            switch (caseType.toLowerCase()) {
                case 'upper': return [`Uppercase: ${text.toUpperCase()}`];
                case 'lower': return [`Lowercase: ${text.toLowerCase()}`];
                case 'title': return [`Title Case: ${text.replace(/\b\w/g, c => c.toUpperCase())}`];
                case 'camel':
                    let camel = text.replace(/(?:^\w|[A-Z]|\b\w)/g, (word, index) => index === 0 ? word.toLowerCase() : word.toUpperCase()).replace(/\s+/g, '');
                    return [`Camel Case: ${camel}`];
                case 'snake': return [`Snake Case: ${text.toLowerCase().replace(/\s+/g, '_')}`];
                case 'kebab': return [`Kebab Case: ${text.toLowerCase().replace(/\s+/g, '-')}`];
                default: return ['Error: Invalid case type. Use `upper`, `lower`, `title`, `camel`, `snake`, or `kebab`.'];
            }
        };

        // Encodes text using ROT13 cipher
        const handleRot13 = (text) => {
            return [`ROT13: ${text.replace(/[a-zA-Z]/g, function(c) {
                return String.fromCharCode((c <= 'Z' ? 90 : 122) >= (c = c.charCodeAt(0) + 13) ? c : c - 26);
            })}`];
        };

        // Converts a Unix timestamp to a human-readable date
        const handleTimestampToDate = (timestamp) => {
            const date = dayjs.unix(timestamp);
            if (!date.isValid()) {
                return ['Error: Invalid timestamp.'];
            }
            return [`Date: ${date.format('YYYY-MM-DD HH:mm:ss Z')}`];
        };

        // Gets the current Unix timestamp and date
        const handleEpochTime = () => {
            const timestamp = dayjs().unix();
            const date = dayjs.unix(timestamp);
            return [`Current Unix Timestamp: ${timestamp}`, `Current Date: ${date.format('YYYY-MM-DD HH:mm:ss Z')}`];
        };

        // Converts Markdown to HTML
        const handleMarkdownToHtml = (md) => {
            let html = md.replace(/^### (.*$)/gim, '<h3>$1</h3>')
                         .replace(/^## (.*$)/gim, '<h2>$1</h2>')
                         .replace(/^# (.*$)/gim, '<h1>$1</h1>')
                         .replace(/\*\*(.*)\*\*/gim, '<b>$1</b>')
                         .replace(/\*(.*)\*/gim, '<i>$1</i>');
            return [`HTML Output:\n${html}`];
        };

        // Converts Markdown to JSON
        const handleMarkdownToJson = (md) => {
            const lines = md.split('\n');
            const sections = {};
            let currentHeading = 'default';
            let currentContent = [];

            lines.forEach(line => {
                const headingMatch = line.match(/^(#+)\s(.*)/);
                if (headingMatch) {
                    if (currentHeading !== 'default') {
                        sections[currentHeading] = currentContent.join('\n').trim();
                    }
                    currentHeading = headingMatch[2].trim();
                    currentContent = [];
                } else {
                    currentContent.push(line);
                }
            });
            if (currentHeading !== 'default') {
                sections[currentHeading] = currentContent.join('\n').trim();
            }

            return [`JSON Output:\n${JSON.stringify(sections, null, 2)}`];
        };

        // Converts JSON to YAML
        const handleJsonToYaml = (jsonString) => {
            try {
                const obj = JSON.parse(jsonString);
                const yaml = jsyaml.dump(obj);
                return [`YAML Output:\n${yaml}`];
            } catch (e) {
                return [strings.invalidJson];
            }
        };

        // Converts YAML to JSON
        const handleYamlToJson = (yamlString) => {
            try {
                const obj = jsyaml.load(yamlString);
                const json = JSON.stringify(obj, null, 2);
                return [`JSON Output:\n${json}`];
            } catch (e) {
                return ['Error: Invalid YAML string.'];
            }
        };

        // Handles DNS lookup
        const handleDnsLookup = async (domain) => {
            try {
                const response = await fetch(`https://cloudflare-dns.com/dns-query?name=${domain}&type=A`, {
                    headers: { 'accept': 'application/dns-json' }
                });
                const data = await response.json();
                if (data.Answer && data.Answer.length > 0) {
                    const ips = data.Answer.map(ans => ` - ${ans.data}`);
                    return ['DNS A Record(s):', '------------------', ...ips];
                } else {
                    return ['No A records found or invalid domain.'];
                }
            } catch (e) {
                return ['Error: DNS lookup failed.'];
            }
        };

        // Handles reverse DNS lookup
        const handleRevDnsLookup = async (ip) => {
            try {
                const response = await fetch(`https://rdap.arin.net/registry/ip/${ip}`);
                const data = await response.json();
                if (data.name) {
                    return [`Reverse DNS for ${ip}: ${data.name}`];
                } else if (data.rdapConformance) {
                    return ['No reverse DNS record found for this IP.'];
                } else {
                    return ['Error: Reverse DNS lookup failed.'];
                }
            } catch (e) {
                return [`Error: Could not connect to API.`];
            }
        };


        // Handles IP geolocation lookup
        const handleIpLookup = async (ip) => {
            try {
                const response = await fetch(`https://ipapi.co/${ip}/json/`);
                const data = await response.json();
                if (data.error) {
                    return [`Error: ${data.reason}`];
                }
                return [
                    'IP Geolocation Results:',
                    '------------------------',
                    `IP:      ${data.ip}`,
                    `Country: ${data.country_name} (${data.country_code})`,
                    `Region:  ${data.region}`,
                    `City:    ${data.city}`,
                    `Latitude: ${data.latitude}`,
                    `Longitude: ${data.longitude}`,
                    `ISP:     ${data.org}`
                ];
            } catch (e) {
                return [`Error: Could not connect to API.`];
            }
        };

        // Gets the user's public IP address
        const handleMyIp = async () => {
            try {
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                if (data.ip) {
                    return [`Your public IP address is: ${data.ip}`];
                } else {
                    return [strings.myIpError];
                }
            } catch (e) {
                return [strings.apiError];
            }
        };

        // Handles data size unit conversion
        const handleUnitConverter = (value, fromUnit, toUnit) => {
            const units = ['B', 'KB', 'MB', 'GB', 'TB'];
            const fromIndex = units.indexOf(fromUnit.toUpperCase());
            const toIndex = units.indexOf(toUnit.toUpperCase());

            if (fromIndex === -1 || toIndex === -1 || isNaN(value)) {
                return [strings.invalidUnit];
            }

            const multiplier = Math.pow(1024, toIndex - fromIndex);
            const result = value * multiplier;
            return [`${value} ${fromUnit} is ${result} ${toUnit}`];
        };

        // Generates a QR code and returns its data URI
        const handleQrCodeGen = (text) => {
            try {
                const qrcode = new QRCode({
                    content: text,
                    padding: 1,
                    width: 256,
                    height: 256,
                    color: "#000000",
                    background: "#ffffff",
                    ecl: "M"
                });
                const dataURI = qrcode.toDataURL();
                return [`QR Code generated. You can view it by copying the data URI below into your browser's address bar:\n\n${dataURI}`, dataURI];
            } catch (e) {
                return ['Error: Failed to generate QR code.'];
            }
        };

        // Decodes a QR code from an image URL
        const handleQrCodeDecode = async (imageUrl) => {
            try {
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.src = imageUrl;

                return new Promise((resolve) => {
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0, img.width, img.height);
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const code = jsQR(imageData.data, imageData.width, imageData.height);

                        if (code) {
                            resolve([`Decoded QR Code: ${code.data}`]);
                        } else {
                            resolve([strings.invalidQr]);
                        }
                    };
                    img.onerror = () => {
                        resolve([strings.invalidQr]);
                    };
                });
            } catch (e) {
                return [strings.invalidQr];
            }
        };

        // Converts an image URL to a grayscale data URI
        const handleImageToGrayscale = (imageUrl) => {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.src = imageUrl;

                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0, img.width, img.height);

                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const pixels = imageData.data;
                    for (let i = 0; i < pixels.length; i += 4) {
                        const r = pixels[i];
                        const g = pixels[i + 1];
                        const b = pixels[i + 2];
                        const gray = (r + g + b) / 3;
                        pixels[i] = gray;
                        pixels[i + 1] = gray;
                        pixels[i + 2] = gray;
                    }
                    ctx.putImageData(imageData, 0, 0);
                    const dataURI = canvas.toDataURL('image/png');
                    resolve([`Grayscale image generated. Data URI below:`, dataURI]);
                };
                img.onerror = () => {
                    resolve([strings.invalidImage]);
                };
            });
        };

        // Shortens a URL using a public API
        const handleUrlShorten = async (url) => {
            try {
                const response = await fetch(`https://tinyurl.com/api-create.php?url=${encodeURIComponent(url)}`);
                const shortUrl = await response.text();
                if (shortUrl.startsWith('https://tinyurl.com')) {
                    return [`Shortened URL: ${shortUrl}`];
                } else {
                    return [strings.urlShortenError];
                }
            } catch (e) {
                return [strings.urlShortenError];
            }
        };

        // Converts an IPv4 address to binary
        const handleIpToBinary = (ip) => {
            const parts = ip.split('.');
            if (parts.length !== 4 || parts.some(p => isNaN(p) || p < 0 || p > 255)) {
                return ['Error: Invalid IPv4 address format.'];
            }
            const binary = parts.map(p => parseInt(p, 10).toString(2).padStart(8, '0')).join('.');
            return [`Binary representation: ${binary}`];
        };

        // Converts a hex color code to RGB
        const handleHexToRgb = (hex) => {
            const hexValue = hex.startsWith('#') ? hex.slice(1) : hex;
            if (!/^[0-9a-fA-F]{6}$/.test(hexValue)) {
                return [strings.invalidHex];
            }
            const r = parseInt(hexValue.substring(0, 2), 16);
            const g = parseInt(hexValue.substring(2, 4), 16);
            const b = parseInt(hexValue.substring(4, 6), 16);
            return [`RGB: ${r}, ${g}, ${b}`];
        };

        // Converts an RGB color code to hex
        const handleRgbToHex = (rgb) => {
            const parts = rgb.split(/[\s,]+/).map(Number);
            if (parts.length !== 3 || parts.some(p => isNaN(p) || p < 0 || p > 255)) {
                return [strings.invalidRgb];
            }
            const toHex = (c) => `0${c.toString(16)}`.slice(-2);
            return [`Hex: #${toHex(parts[0])}${toHex(parts[1])}${toHex(parts[2])}`];
        };

        // Validates an email address using a regex
        const handleValidateEmail = (email) => {
            const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (regex.test(email)) {
                return ['Email is valid.'];
            } else {
                return [strings.invalidEmail];
            }
        };

        // Validates a credit card number using the Luhn algorithm
        const handleValidateCreditCard = (cardNumber) => {
            const cleaned = cardNumber.replace(/\D/g, '');
            if (cleaned.length < 13 || cleaned.length > 19) {
                return [strings.invalidCreditCard];
            }
            let sum = 0;
            let shouldDouble = false;
            for (let i = cleaned.length - 1; i >= 0; i--) {
                let digit = parseInt(cleaned.charAt(i), 10);
                if (shouldDouble) {
                    digit *= 2;
                    if (digit > 9) digit -= 9;
                }
                sum += digit;
                shouldDouble = !shouldDouble;
            }
            if (sum % 10 === 0) {
                return ['Credit card number is valid.'];
            } else {
                return [strings.luhnCheckFailed];
            }
        };

        // Displays the user's browser User-Agent string
        const handleUserAgent = () => {
            return [`User-Agent: ${navigator.userAgent}`];
        };

        // --- Main App Component ---
        const App = () => {
            // State for the CLI
            const [terminalOutput, setTerminalOutput] = useState([]);
            const [currentInput, setCurrentInput] = useState('');
            const [isProcessing, setIsProcessing] = useState(false);
            const [isGuiMode, setIsGuiMode] = useState(false);
            const terminalRef = useRef(null);

            // State for the GUI
            const [tool, setTool] = useState('password-gen');
            const [inputValue, setInputValue] = useState('');
            const [guiOutput, setGuiOutput] = useState([]);
            const [outputType, setOutputType] = useState('text');
            const [qrImageSrc, setQrImageSrc] = useState('');

            // State for the custom dropdown
            const [isDropdownOpen, setIsDropdownOpen] = useState(false);
            const dropdownRef = useRef(null);

            const asciiHeader = [
                '                                                                     ',
                ' ##################################################################  ',
                ' ##                                                              ##  ',
                ' ##               _   _   _   _   _   _   _   _   _              ##  ',
                ' ##              / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\             ##  ',
                ' ##             ( C | O | D | R | A | . | C | L | I )            ##  ',
                ' ##              \\_/ \\_/ \\_/ \\_/ \\_/ \\_/ \\_/ \\_/ \\_/             ##',
                ' ##                                                              ##  ',
                ' ##                 (●´Д｀●)      (●´Д｀●)      (●´Д｀●)         ##  ',
                ' ##                                                              ##  ',
                ' ##################################################################  ',
                '                                                                     '
            ];

            const welcomeMessage = [
                strings.welcome,
                strings.help,
                strings.gui,
                ''
            ];

            // Local Storage and Scroll Effects
            useEffect(() => {
                const savedOutput = localStorage.getItem('terminalOutput');
                if (savedOutput) {
                    setTerminalOutput(JSON.parse(savedOutput));
                } else {
                    setTerminalOutput([...asciiHeader, ...welcomeMessage]);
                }
            }, []);

            useEffect(() => {
                try {
                    localStorage.setItem('terminalOutput', JSON.stringify(terminalOutput));
                } catch (e) {
                    console.error("Could not save to local storage: ", e);
                }
            }, [terminalOutput]);

            useEffect(() => {
                if (terminalRef.current) {
                    terminalRef.current.scrollTop = terminalRef.current.scrollHeight;
                }
            }, [terminalOutput]);

            // Handles clicks outside the dropdown to close it
            useEffect(() => {
                const handleClickOutside = (event) => {
                    if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
                        setIsDropdownOpen(false);
                    }
                };
                document.addEventListener("mousedown", handleClickOutside);
                return () => {
                    document.removeEventListener("mousedown", handleClickOutside);
                };
            }, [dropdownRef]);


            // Command Handlers
            const handleCommand = async (command) => {
                setIsProcessing(true);
                const args = command.trim().split(/\s+/);
                const cmd = args[0].toLowerCase();
                setTerminalOutput(prev => [...prev, `> ${command}`, '']);
                let output = [];

                switch (cmd) {
                    case 'help':
                        output = [strings.commandsTitle, '-------------------', ...strings.commands, ''];
                        break;

                    case 'gui':
                        setIsGuiMode(true);
                        output = [strings.gui];
                        break;

                    case 'clear':
                        setTerminalOutput([]);
                        setIsProcessing(false);
                        return;

                    case 'clear-history':
                        localStorage.removeItem('terminalOutput');
                        setTerminalOutput(['Terminal history cleared. Your session will not be saved on reload.']);
                        setIsProcessing(false);
                        return;

                    case 'exit':
                        if (isGuiMode) {
                            setIsGuiMode(false);
                            output = [strings.cli];
                        } else {
                            output = [strings.exit];
                        }
                        break;

                    case 'password-check':
                        if (args.length < 2) {
                            output = [`${strings.missingArg} Usage: password-check <password>`];
                        } else {
                            output = handlePasswordCheck(args.slice(1).join(' '));
                        }
                        break;

                    case 'password-gen':
                        output = handlePasswordGen();
                        break;

                    case 'base64':
                        if (args.length < 3) {
                            output = [`${strings.missingArg} Usage: base64 <encode|decode> <text>`];
                        } else {
                            output = handleBase64(args[1], args.slice(2).join(' '));
                        }
                        break;

                    case 'url-encode':
                    case 'url-decode':
                        if (args.length < 2) {
                            output = [`${strings.missingArg} Usage: ${cmd} <text>`];
                        } else {
                            output = handleUrlEncodeDecode(cmd, args.slice(1).join(' '));
                        }
                        break;

                    case 'hash':
                        if (args.length < 2) {
                            output = [`${strings.missingArg} Usage: hash <text>`];
                        } else {
                            output = await handleTextHash(args.slice(1).join(' '));
                        }
                        break;

                    case 'json-format':
                        if (args.length < 2) {
                            output = [`${strings.missingArg} Usage: json-format <json_string>`];
                        } else {
                            output = handleJsonFormat(args.slice(1).join(' '));
                        }
                        break;

                    case 'string-reverse':
                        if (args.length < 2) {
                            output = [`${strings.missingArg} Usage: string-reverse <text>`];
                        } else {
                            output = handleStringReverse(args.slice(1).join(' '));
                        }
                        break;

                    case 'string-count':
                        if (args.length < 2) {
                            output = [`${strings.missingArg} Usage: string-count <text>`];
                        } else {
                            output = handleStringCount(args.slice(1).join(' '));
                        }
                        break;

                    case 'case-convert':
                        if (args.length < 3) {
                            output = [`${strings.missingArg} Usage: case-convert <case> <text>`];
                        } else {
                            output = handleCaseConvert(args[1], args.slice(2).join(' '));
                        }
                        break;

                    case 'rot13':
                        if (args.length < 2) {
                            output = [`${strings.missingArg} Usage: rot13 <text>`];
                        } else {
                            output = handleRot13(args.slice(1).join(' '));
                        }
                        break;

                    case 'epoch':
                        output = handleEpochTime();
                        break;

                    case 'timestamp-to-date':
                        if (args.length < 2) {
                            output = [`${strings.missingArg} Usage: timestamp-to-date <timestamp>`];
                        } else {
                            output = handleTimestampToDate(args[1]);
                        }
                        break;

                    case 'markdown-to-html':
                        if (args.length < 2) {
                            output = [`${strings.missingArg} Usage: markdown-to-html <text>`];
                        } else {
                            output = handleMarkdownToHtml(args.slice(1).join(' '));
                        }
                        break;

                    case 'markdown-to-json':
                        if (args.length < 2) {
                            output = [`${strings.missingArg} Usage: markdown-to-json <text>`];
                        } else {
                            output = handleMarkdownToJson(args.slice(1).join(' '));
                        }
                        break;

                    case 'json-to-yaml':
                        if (args.length < 2) {
                            output = [`${strings.missingArg} Usage: json-to-yaml <json_string>`];
                        } else {
                            output = handleJsonToYaml(args.slice(1).join(' '));
                        }
                        break;

                    case 'yaml-to-json':
                        if (args.length < 2) {
                            output = [`${strings.missingArg} Usage: yaml-to-json <yaml_string>`];
                        } else {
                            output = handleYamlToJson(args.slice(1).join(' '));
                        }
                        break;

                    case 'convert':
                        if (args.length < 5 || args[3].toLowerCase() !== 'to') {
                            output = [strings.invalidUnit];
                        } else {
                            output = handleUnitConverter(parseFloat(args[1]), args[2], args[4]);
                        }
                        break;

                    case 'qrcode-gen':
                        if (args.length < 2) {
                            output = [`${strings.missingArg} Usage: qrcode-gen <text>`];
                        } else {
                            output = handleQrCodeGen(args.slice(1).join(' '));
                        }
                        break;

                    case 'qrcode-decode':
                        if (args.length < 2) {
                            output = [`${strings.missingArg} Usage: qrcode-decode <image_url>`];
                        } else {
                            output = await handleQrCodeDecode(args[1]);
                        }
                        break;

                    case 'image-to-grayscale':
                        if (args.length < 2) {
                            output = [`${strings.missingArg} Usage: image-to-grayscale <image_url>`];
                        } else {
                            output = await handleImageToGrayscale(args[1]);
                        }
                        break;

                    case 'base64-to-image':
                        if (args.length < 2) {
                            output = [`${strings.missingArg} Usage: base64-to-image <base64_string>`];
                        } else {
                            const b64 = args.slice(1).join(' ');
                            if (b64.startsWith('data:image/')) {
                                output = [`Image decoded.`, b64];
                            } else {
                                output = [`Image decoded.`, `data:image/png;base64,${b64}`];
                            }
                        }
                        break;

                    case 'url-shorten':
                        if (args.length < 2) {
                            output = [`${strings.missingArg} Usage: url-shorten <url>`];
                        } else {
                            output = await handleUrlShorten(args[1]);
                        }
                        break;

                    case 'ip-to-binary':
                        if (args.length < 2) {
                            output = [`${strings.missingArg} Usage: ip-to-binary <ip>`];
                        } else {
                            output = handleIpToBinary(args[1]);
                        }
                        break;

                    case 'hex-to-rgb':
                        if (args.length < 2) {
                            output = [`${strings.missingArg} Usage: hex-to-rgb <hex_code>`];
                        } else {
                            output = handleHexToRgb(args[1]);
                        }
                        break;

                    case 'rgb-to-hex':
                        if (args.length < 2) {
                            output = [`${strings.missingArg} Usage: rgb-to-hex <r,g,b>`];
                        } else {
                            output = handleRgbToHex(args.slice(1).join(''));
                        }
                        break;

                    case 'validate-email':
                        if (args.length < 2) {
                            output = [`${strings.missingArg} Usage: validate-email <email>`];
                        } else {
                            output = handleValidateEmail(args[1]);
                        }
                        break;

                    case 'validate-credit-card':
                        if (args.length < 2) {
                            output = [`${strings.missingArg} Usage: validate-credit-card <number>`];
                        } else {
                            output = handleValidateCreditCard(args[1]);
                        }
                        break;

                    case 'user-agent':
                        output = handleUserAgent();
                        break;

                    case 'myip':
                        output = await handleMyIp();
                        break;

                    case 'ip':
                        if (args.length < 2) {
                            output = [`${strings.missingArg} Usage: ip <address>`];
                        } else {
                            output = await handleIpLookup(args[1]);
                        }
                        break;

                    case 'rev-dns':
                        if (args.length < 2) {
                            output = [`${strings.missingArg} Usage: rev-dns <ip>`];
                        } else {
                            output = await handleRevDnsLookup(args[1]);
                        }
                        break;

                    case 'dns-lookup':
                        if (args.length < 2) {
                            output = [`${strings.missingArg} Usage: dns-lookup <domain>`];
                        } else {
                            output = await handleDnsLookup(args[1]);
                        }
                        break;

                    default:
                        output = [`${strings.error} ${command}`, strings.help];
                        break;
                }

                setTerminalOutput(prev => [...prev, ...output, '']);
                setIsProcessing(false);
            };

            const handleKeyDown = (e) => {
                if (e.key === 'Enter' && !isProcessing) {
                    const command = currentInput.trim();
                    if (command) {
                        handleCommand(command);
                        setCurrentInput('');
                    }
                }
            };

            const runTool = async () => {
                let output;
                let value, fromUnit, toUnit, hex;
                setOutputType('text');
                setQrImageSrc('');

                switch (tool) {
                    case 'password-gen':
                        output = handlePasswordGen();
                        break;
                    case 'password-check':
                        output = handlePasswordCheck(inputValue);
                        break;
                    case 'url-encode':
                        output = handleUrlEncodeDecode('url-encode', inputValue);
                        break;
                    case 'url-decode':
                        output = handleUrlEncodeDecode('url-decode', inputValue);
                        break;
                    case 'base64-encode':
                        output = handleBase64('encode', inputValue);
                        break;
                    case 'base64-decode':
                        output = handleBase64('decode', inputValue);
                        break;
                    case 'myip':
                         output = await handleMyIp();
                         break;
                    case 'qr-gen':
                        output = handleQrCodeGen(inputValue);
                        if (output[1] && output[1].startsWith('data:image')) {
                            setQrImageSrc(output[1]);
                            setOutputType('image');
                            output = [output[0]]; // Keep only the text message for display
                        }
                        break;
                    case 'qr-decode':
                        output = await handleQrCodeDecode(inputValue);
                        break;
                    case 'unit-converter':
                        const parts = inputValue.split(/\s+/);
                        if (parts.length === 4 && parts[2].toLowerCase() === 'to') {
                            value = parseFloat(parts[0]);
                            fromUnit = parts[1];
                            toUnit = parts[3];
                            output = handleUnitConverter(value, fromUnit, toUnit);
                        } else {
                            output = [strings.invalidUnit];
                        }
                        break;
                    case 'rev-dns':
                        output = await handleRevDnsLookup(inputValue);
                        break;
                    case 'image-to-grayscale':
                        output = await handleImageToGrayscale(inputValue);
                        if (output[1] && output[1].startsWith('data:image')) {
                            setQrImageSrc(output[1]);
                            setOutputType('image');
                            output = [output[0]]; // Keep only the text message for display
                        }
                        break;
                    case 'base64-to-image':
                        let b64 = inputValue.trim();
                        if (!b64.startsWith('data:image')) {
                            b64 = `data:image/png;base64,${b64}`;
                        }
                        setQrImageSrc(b64);
                        setOutputType('image');
                        output = ['Base64 string decoded to image.'];
                        break;
                    case 'url-shorten':
                        output = await handleUrlShorten(inputValue);
                        break;
                    case 'ip-to-binary':
                        output = handleIpToBinary(inputValue);
                        break;
                    case 'markdown-to-json':
                        output = handleMarkdownToJson(inputValue);
                        break;
                    case 'hex-to-rgb':
                        output = handleHexToRgb(inputValue);
                        break;
                    case 'rgb-to-hex':
                        output = handleRgbToHex(inputValue);
                        break;
                    case 'validate-email':
                        output = handleValidateEmail(inputValue);
                        break;
                    case 'validate-credit-card':
                        output = handleValidateCreditCard(inputValue);
                        break;
                    case 'user-agent':
                        output = handleUserAgent();
                        break;
                    default:
                        output = ['Please select a tool.'];
                        break;
                }
                setGuiOutput(output);
            };

            const getToolName = (id) => {
                for (const group in toolOptions) {
                    const tool = toolOptions[group].find(t => t.id === id);
                    if (tool) return tool.name;
                }
                return id;
            };

            // Main render logic: chooses between Terminal and GUI
            const showInputField = !['password-gen', 'myip', 'user-agent'].includes(tool);

            return (
                <div
                    className="flex flex-col items-center justify-center min-h-screen p-4 font-mono text-sm sm:text-base bg-gray-900 text-green-400"
                    style={{
                        backgroundImage: `
                            radial-gradient(circle at 1px 1px, rgba(55, 65, 81, 0.5) 1px, transparent 0),
                            radial-gradient(circle at 1px 1px, rgba(55, 65, 81, 0.5) 1px, transparent 0)
                        `,
                        backgroundSize: '24px 24px',
                        backgroundPosition: '0 0, 12px 12px'
                    }}
                >
                    {!isGuiMode ? (
                        <div
                            ref={terminalRef}
                            className="w-full max-w-5xl h-[80vh] bg-black bg-opacity-80 rounded-xl border-4 border-gray-700 p-6 overflow-y-scroll scrollbar-hide shadow-2xl terminal-font"
                            onClick={() => document.getElementById('terminal-input').focus()}
                        >
                            <pre className="whitespace-pre-wrap leading-tight">
                                {terminalOutput.map((line, index) => (
                                    <span key={index}>{line}<br /></span>
                                ))}
                                <span className="flex items-center">
                                    <span className="mr-2">&gt;</span>
                                    <input
                                        id="terminal-input"
                                        type="text"
                                        className="flex-grow bg-transparent text-green-400 focus:outline-none"
                                        value={currentInput}
                                        onChange={(e) => setCurrentInput(e.target.value)}
                                        onKeyDown={handleKeyDown}
                                        disabled={isProcessing}
                                        autoFocus
                                    />
                                </span>
                            </pre>
                        </div>
                    ) : (
                        <div className="p-4 w-full max-w-5xl">
                            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                {/* Top Title Section */}
                                <div className="col-span-1 md:col-span-3 p-6 bg-black bg-opacity-80 rounded-xl border-4 border-gray-700 text-center">
                                    <div className="text-2xl font-bold text-green-400">Codra GUI</div>
                                    <div className="text-xs text-gray-500 mt-1">A collection of dev/sec tools</div>
                                </div>

                                {/* Tool Selection */}
                                <div className="p-6 bg-black bg-opacity-80 rounded-xl border-4 border-gray-700 relative" ref={dropdownRef}>
                                    <label htmlFor="tool-select" className="block text-gray-400 mb-2 terminal-font">Select a Tool:</label>
                                    <button
                                        onClick={() => setIsDropdownOpen(!isDropdownOpen)}
                                        className="w-full text-left bg-black bg-opacity-80 border border-gray-700 text-green-400 px-3 py-2 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 flex justify-between items-center gui-select-button"
                                    >
                                        <span className="truncate">{getToolName(tool)}</span>
                                        <svg
                                            className={`w-4 h-4 ml-2 text-gray-400 transition-transform duration-200 ${isDropdownOpen ? 'rotate-180' : ''}`}
                                            fill="none"
                                            stroke="currentColor"
                                            viewBox="0 0 24 24"
                                            xmlns="http://www.w3.org/2000/svg"
                                        >
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path>
                                        </svg>
                                    </button>
                                    {isDropdownOpen && (
                                        <div className="absolute z-10 w-full mt-2 bg-black bg-opacity-90 rounded-lg shadow-xl max-h-60 overflow-y-auto ring-1 ring-gray-700 scrollbar-hide">
                                            {Object.keys(toolOptions).map(group => (
                                                <div key={group}>
                                                    <div className="text-gray-500 text-xs px-4 py-2 uppercase font-bold sticky top-0 bg-black bg-opacity-90">{group}</div>
                                                    {toolOptions[group].map(option => (
                                                        <div
                                                            key={option.id}
                                                            onClick={() => {
                                                                setTool(option.id);
                                                                setInputValue('');
                                                                setGuiOutput([]);
                                                                setQrImageSrc('');
                                                                setIsDropdownOpen(false);
                                                            }}
                                                            className="text-green-400 terminal-font px-4 py-2 cursor-pointer hover:bg-gray-800 transition-colors duration-150"
                                                        >
                                                            {option.name}
                                                        </div>
                                                    ))}
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                </div>


                                {/* Input Field Section (Conditional) */}
                                {showInputField && (
                                    <div className="p-6 bg-black bg-opacity-80 rounded-xl border-4 border-gray-700 col-span-1">
                                        <label htmlFor="input-field" className="block text-gray-400 mb-2 terminal-font">Input:</label>
                                        <input
                                            id="input-field"
                                            type="text"
                                            className="gui-input terminal-font"
                                            value={inputValue}
                                            onChange={(e) => setInputValue(e.target.value)}
                                            placeholder={strings.inputPlaceholder}
                                        />
                                        {tool === 'unit-converter' && (
                                            <p className="text-gray-500 text-xs mt-1">Format: '1024 B to KB'</p>
                                        )}
                                    </div>
                                )}

                                {/* Run Button Section */}
                                <div className="p-6 bg-black bg-opacity-80 rounded-xl border-4 border-gray-700 col-span-1 md:col-span-1 flex items-center justify-center">
                                    <button
                                        onClick={runTool}
                                        className="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg transition-colors duration-200 w-full"
                                    >
                                        {strings.run}
                                    </button>
                                </div>

                                {/* Output Section */}
                                {guiOutput.length > 0 && (
                                    <div className="p-6 bg-black bg-opacity-80 rounded-xl border-4 border-gray-700 col-span-1 md:col-span-2 row-span-2">
                                        <h3 className="text-gray-400 mb-2 font-bold terminal-font">{strings.output}</h3>
                                        {outputType === 'text' && (
                                            <pre className="whitespace-pre-wrap terminal-font leading-tight text-green-400">
                                                {guiOutput.map((line, index) => (
                                                    <div key={index}>{line}</div>
                                                ))}
                                            </pre>
                                        )}
                                        {outputType === 'image' && (
                                            <div className="flex flex-col items-center">
                                                <img src={qrImageSrc} alt="Generated output image" className="mx-auto mt-4 w-auto h-auto max-w-full border-4 border-gray-700 rounded-lg" />
                                                <pre className="whitespace-pre-wrap terminal-font leading-tight text-green-400 mt-4">
                                                    {guiOutput.map((line, index) => (
                                                        <div key={index}>{line}</div>
                                                    ))}
                                                </pre>
                                            </div>
                                        )}
                                    </div>
                                )}

                                {/* Return Button Section */}
                                <div className="p-6 bg-black bg-opacity-80 rounded-xl border-4 border-gray-700 col-span-1 md:col-span-1 flex items-center justify-center">
                                    <button
                                        onClick={() => setIsGuiMode(false)}
                                        className="bg-gray-700 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg transition-colors duration-200 w-full"
                                    >
                                        {strings.returnToCli}
                                    </button>
                                </div>
                            </div>
                            {/* New 'Made with' footer */}
                            <div className="mt-8 text-center text-gray-500 text-xs">
                                Made with ❤️ by arXiVius
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // Render the main App component
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
